export const demoExpectations = {
  planarity: [
    'Determines whether the input graph is planar under its topology.',
    'Returns a deterministic rotation system when planar.',
    'Surfaces a Kuratowski witness edge set when nonplanar.',
    'Does not attempt to “fix” nonplanar graphs automatically.',
    'Embedding output is stable given the same insertion order.',
    'Witness edges are for debugging and inspection only.',
  ],
  embedding: [
    'Builds a half-edge structure from a rotation system.',
    'Enumerates faces with closed boundary walks.',
    'Guarantees each half-edge has a twin and consistent next/prev cycles.',
    'Exposes dual adjacency derived from face boundaries.',
    'No layout is produced; this is pure topology.',
    'Self-loops are supported and compiled into paired half-edges.',
  ],
  bcTree: [
    'Separates blocks (biconnected components) from cut vertices.',
    'Every undirected edge belongs to exactly one block.',
    'Articulation vertices appear as shared nodes in the BC-tree.',
    'No reordering or layout is applied here.',
    'Stable iteration order preserves block IDs across runs.',
    'Blocks are reported as edge sets rather than vertex-induced subgraphs.',
  ],
  spqr: [
    'Builds the SPQR tree for biconnected planar blocks (falls back to the largest block if needed).',
    'Exposes S/P/R/Q node types and skeleton graphs.',
    'Supports valid flips/permutes where allowed by topology.',
    'Does not select a final embedding unless asked.',
    'Deterministic decomposition for identical inputs.',
    'Skeletons are reported in the same insertion order as the source graph.',
  ],
  stBipolar: [
    'Computes st-numbering for a chosen (s,t) on a biconnected graph.',
    'Derives a bipolar orientation from an embedded planar graph.',
    'Guarantees a unique source (s) and sink (t).',
    'Internal vertices have both incoming and outgoing edges.',
    'No coordinates are produced in this step.',
    'Inputs must be biconnected for st-numbering to succeed.',
  ],
  dualRouting: [
    'Constructs the dual graph from the current embedding.',
    'Shortest paths are computed over faces, not vertices.',
    'Routes return crossed primal edges + face sequence.',
    'Weights are user-configurable and deterministic.',
    'Nonplanar inputs are reduced to a maximal planar backbone before routing.',
    'Multiple edges in the dual are preserved for multi-edge faces.',
  ],
  minCostFlow: [
    'Solves min-cost flow with capacities and costs.',
    'Supports supply/demand and circulation modes.',
    'Outputs flows, costs, and reduced costs when available.',
    'Deterministic solver with stable tie-breaking.',
    'Does not mutate the input network.',
    'Lower bounds are enforced via feasibility transform.',
  ],
  orthogonal: [
    'Produces an orthogonal representation with minimized bends.',
    'Uses min-cost flow under Tamassia-style constraints.',
    'Directed inputs are treated as undirected for geometry.',
    'Compaction yields integer grid coordinates.',
    'Reports bend counts and area metrics.',
    'No renderer-specific styling is applied.',
    'Nonplanar inputs are planarized before orthogonal routing.',
  ],
  planarization: [
    'Finds a maximal planar subgraph as the backbone.',
    'Inserts remaining edges via dual shortest paths.',
    'Crossings are converted to dummy vertices for layout.',
    'Outputs both intermediate planarized and final drawings.',
    'Crossings are explicitly marked, not hidden.',
    'Edge insertion order is deterministic (insertion-order).',
  ],
} as const;
